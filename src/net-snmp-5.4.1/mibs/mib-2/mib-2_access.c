
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.access_functions.conf 11358 2004-10-14 12:57:34Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "mib-2_access.h"
#include "mib-2_enums.h"


/** returns the first data point within the sysORTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
sysORTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: sysORIndex data */, /** XXX: length of sysORIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as sysORTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
sysORTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: sysORIndex data */, /** XXX: length of sysORIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
sysORTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
sysORTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table sysORTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the sysORID column and set
         ret_len to its proper size in bytes. */
      oid *get_sysORID(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the sysORDescr column and set
         ret_len to its proper size in bytes. */
      char *get_sysORDescr(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the sysORUpTime column and set
         ret_len to its proper size in bytes. */
      u_long *get_sysORUpTime(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
    

/** returns the first data point within the ifTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
ifTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifIndex data */, /** XXX: length of ifIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as ifTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
ifTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifIndex data */, /** XXX: length of ifIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
ifTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
ifTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table ifTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the ifIndex column and set
         ret_len to its proper size in bytes. */
      long *get_ifIndex(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifDescr column and set
         ret_len to its proper size in bytes. */
      char *get_ifDescr(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifType column and set
         ret_len to its proper size in bytes. */
      long *get_ifType(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifMtu column and set
         ret_len to its proper size in bytes. */
      long *get_ifMtu(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifSpeed column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifSpeed(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifPhysAddress column and set
         ret_len to its proper size in bytes. */
      char *get_ifPhysAddress(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifAdminStatus column and set
         ret_len to its proper size in bytes. */
      long *get_ifAdminStatus(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ifAdminStatus column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ifAdminStatus(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ifOperStatus column and set
         ret_len to its proper size in bytes. */
      long *get_ifOperStatus(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifLastChange column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifLastChange(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifInOctets column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifInOctets(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifInUcastPkts column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifInUcastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifInNUcastPkts column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifInNUcastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifInDiscards column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifInDiscards(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifInErrors column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifInErrors(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifInUnknownProtos column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifInUnknownProtos(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifOutOctets column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifOutOctets(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifOutUcastPkts column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifOutUcastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifOutNUcastPkts column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifOutNUcastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifOutDiscards column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifOutDiscards(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifOutErrors column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifOutErrors(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifOutQLen column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifOutQLen(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifSpecific column and set
         ret_len to its proper size in bytes. */
      oid *get_ifSpecific(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
    

/** returns the first data point within the atTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: atIfIndex data */, /** XXX: length of atIfIndex data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: atNetAddress data */, /** XXX: length of atNetAddress data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
atTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: atIfIndex data */, /** XXX: length of atIfIndex data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: atNetAddress data */, /** XXX: length of atNetAddress data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
atTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
atTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table atTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the atIfIndex column and set
         ret_len to its proper size in bytes. */
      long *get_atIfIndex(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the atIfIndex column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_atIfIndex(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the atPhysAddress column and set
         ret_len to its proper size in bytes. */
      char *get_atPhysAddress(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the atPhysAddress column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_atPhysAddress(void *data_context, char *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the atNetAddress column and set
         ret_len to its proper size in bytes. */
       *get_atNetAddress(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the atNetAddress column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_atNetAddress(void *data_context,  *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
    

/** returns the first data point within the ipAddrTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
ipAddrTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ipAdEntAddr data */, /** XXX: length of ipAdEntAddr data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as ipAddrTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
ipAddrTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ipAdEntAddr data */, /** XXX: length of ipAdEntAddr data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
ipAddrTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
ipAddrTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table ipAddrTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the ipAdEntAddr column and set
         ret_len to its proper size in bytes. */
      u_long *get_ipAdEntAddr(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ipAdEntIfIndex column and set
         ret_len to its proper size in bytes. */
      long *get_ipAdEntIfIndex(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ipAdEntNetMask column and set
         ret_len to its proper size in bytes. */
      u_long *get_ipAdEntNetMask(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ipAdEntBcastAddr column and set
         ret_len to its proper size in bytes. */
      long *get_ipAdEntBcastAddr(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ipAdEntReasmMaxSize column and set
         ret_len to its proper size in bytes. */
      long *get_ipAdEntReasmMaxSize(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
    

/** returns the first data point within the ipRouteTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
ipRouteTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ipRouteDest data */, /** XXX: length of ipRouteDest data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as ipRouteTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
ipRouteTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ipRouteDest data */, /** XXX: length of ipRouteDest data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
ipRouteTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
ipRouteTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table ipRouteTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the ipRouteDest column and set
         ret_len to its proper size in bytes. */
      u_long *get_ipRouteDest(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipRouteDest column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipRouteDest(void *data_context, u_long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipRouteIfIndex column and set
         ret_len to its proper size in bytes. */
      long *get_ipRouteIfIndex(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipRouteIfIndex column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipRouteIfIndex(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipRouteMetric1 column and set
         ret_len to its proper size in bytes. */
      long *get_ipRouteMetric1(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipRouteMetric1 column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipRouteMetric1(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipRouteMetric2 column and set
         ret_len to its proper size in bytes. */
      long *get_ipRouteMetric2(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipRouteMetric2 column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipRouteMetric2(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipRouteMetric3 column and set
         ret_len to its proper size in bytes. */
      long *get_ipRouteMetric3(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipRouteMetric3 column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipRouteMetric3(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipRouteMetric4 column and set
         ret_len to its proper size in bytes. */
      long *get_ipRouteMetric4(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipRouteMetric4 column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipRouteMetric4(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipRouteNextHop column and set
         ret_len to its proper size in bytes. */
      u_long *get_ipRouteNextHop(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipRouteNextHop column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipRouteNextHop(void *data_context, u_long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipRouteType column and set
         ret_len to its proper size in bytes. */
      long *get_ipRouteType(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipRouteType column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipRouteType(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipRouteProto column and set
         ret_len to its proper size in bytes. */
      long *get_ipRouteProto(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ipRouteAge column and set
         ret_len to its proper size in bytes. */
      long *get_ipRouteAge(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipRouteAge column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipRouteAge(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipRouteMask column and set
         ret_len to its proper size in bytes. */
      u_long *get_ipRouteMask(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipRouteMask column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipRouteMask(void *data_context, u_long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipRouteMetric5 column and set
         ret_len to its proper size in bytes. */
      long *get_ipRouteMetric5(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipRouteMetric5 column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipRouteMetric5(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipRouteInfo column and set
         ret_len to its proper size in bytes. */
      oid *get_ipRouteInfo(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
    

/** returns the first data point within the ipNetToMediaTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
ipNetToMediaTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ipNetToMediaIfIndex data */, /** XXX: length of ipNetToMediaIfIndex data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: ipNetToMediaNetAddress data */, /** XXX: length of ipNetToMediaNetAddress data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as ipNetToMediaTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
ipNetToMediaTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ipNetToMediaIfIndex data */, /** XXX: length of ipNetToMediaIfIndex data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: ipNetToMediaNetAddress data */, /** XXX: length of ipNetToMediaNetAddress data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
ipNetToMediaTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
ipNetToMediaTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table ipNetToMediaTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the ipNetToMediaIfIndex column and set
         ret_len to its proper size in bytes. */
      long *get_ipNetToMediaIfIndex(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipNetToMediaIfIndex column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipNetToMediaIfIndex(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipNetToMediaPhysAddress column and set
         ret_len to its proper size in bytes. */
      char *get_ipNetToMediaPhysAddress(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipNetToMediaPhysAddress column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipNetToMediaPhysAddress(void *data_context, char *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipNetToMediaNetAddress column and set
         ret_len to its proper size in bytes. */
      u_long *get_ipNetToMediaNetAddress(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipNetToMediaNetAddress column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipNetToMediaNetAddress(void *data_context, u_long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ipNetToMediaType column and set
         ret_len to its proper size in bytes. */
      long *get_ipNetToMediaType(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ipNetToMediaType column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ipNetToMediaType(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
    

/** returns the first data point within the tcpConnTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
tcpConnTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: tcpConnLocalAddress data */, /** XXX: length of tcpConnLocalAddress data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: tcpConnLocalPort data */, /** XXX: length of tcpConnLocalPort data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: tcpConnRemAddress data */, /** XXX: length of tcpConnRemAddress data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: tcpConnRemPort data */, /** XXX: length of tcpConnRemPort data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as tcpConnTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
tcpConnTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: tcpConnLocalAddress data */, /** XXX: length of tcpConnLocalAddress data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: tcpConnLocalPort data */, /** XXX: length of tcpConnLocalPort data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: tcpConnRemAddress data */, /** XXX: length of tcpConnRemAddress data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: tcpConnRemPort data */, /** XXX: length of tcpConnRemPort data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
tcpConnTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
tcpConnTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table tcpConnTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the tcpConnState column and set
         ret_len to its proper size in bytes. */
      long *get_tcpConnState(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the tcpConnState column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_tcpConnState(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the tcpConnLocalAddress column and set
         ret_len to its proper size in bytes. */
      u_long *get_tcpConnLocalAddress(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the tcpConnLocalPort column and set
         ret_len to its proper size in bytes. */
      long *get_tcpConnLocalPort(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the tcpConnRemAddress column and set
         ret_len to its proper size in bytes. */
      u_long *get_tcpConnRemAddress(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the tcpConnRemPort column and set
         ret_len to its proper size in bytes. */
      long *get_tcpConnRemPort(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
    

/** returns the first data point within the udpTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
udpTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: udpLocalAddress data */, /** XXX: length of udpLocalAddress data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: udpLocalPort data */, /** XXX: length of udpLocalPort data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as udpTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
udpTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: udpLocalAddress data */, /** XXX: length of udpLocalAddress data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: udpLocalPort data */, /** XXX: length of udpLocalPort data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
udpTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
udpTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table udpTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the udpLocalAddress column and set
         ret_len to its proper size in bytes. */
      u_long *get_udpLocalAddress(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the udpLocalPort column and set
         ret_len to its proper size in bytes. */
      long *get_udpLocalPort(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
    

/** returns the first data point within the egpNeighTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
egpNeighTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: egpNeighAddr data */, /** XXX: length of egpNeighAddr data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as egpNeighTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
egpNeighTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: egpNeighAddr data */, /** XXX: length of egpNeighAddr data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
egpNeighTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
egpNeighTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table egpNeighTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the egpNeighState column and set
         ret_len to its proper size in bytes. */
      long *get_egpNeighState(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighAddr column and set
         ret_len to its proper size in bytes. */
      u_long *get_egpNeighAddr(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighAs column and set
         ret_len to its proper size in bytes. */
      long *get_egpNeighAs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighInMsgs column and set
         ret_len to its proper size in bytes. */
      u_long *get_egpNeighInMsgs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighInErrs column and set
         ret_len to its proper size in bytes. */
      u_long *get_egpNeighInErrs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighOutMsgs column and set
         ret_len to its proper size in bytes. */
      u_long *get_egpNeighOutMsgs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighOutErrs column and set
         ret_len to its proper size in bytes. */
      u_long *get_egpNeighOutErrs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighInErrMsgs column and set
         ret_len to its proper size in bytes. */
      u_long *get_egpNeighInErrMsgs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighOutErrMsgs column and set
         ret_len to its proper size in bytes. */
      u_long *get_egpNeighOutErrMsgs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighStateUps column and set
         ret_len to its proper size in bytes. */
      u_long *get_egpNeighStateUps(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighStateDowns column and set
         ret_len to its proper size in bytes. */
      u_long *get_egpNeighStateDowns(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighIntervalHello column and set
         ret_len to its proper size in bytes. */
      long *get_egpNeighIntervalHello(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighIntervalPoll column and set
         ret_len to its proper size in bytes. */
      long *get_egpNeighIntervalPoll(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighMode column and set
         ret_len to its proper size in bytes. */
      long *get_egpNeighMode(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the egpNeighEventTrigger column and set
         ret_len to its proper size in bytes. */
      long *get_egpNeighEventTrigger(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the egpNeighEventTrigger column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_egpNeighEventTrigger(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
    

/** returns the first data point within the rs232PortTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
rs232PortTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232PortIndex data */, /** XXX: length of rs232PortIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as rs232PortTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
rs232PortTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232PortIndex data */, /** XXX: length of rs232PortIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
rs232PortTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
rs232PortTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table rs232PortTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the rs232PortIndex column and set
         ret_len to its proper size in bytes. */
      long *get_rs232PortIndex(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232PortType column and set
         ret_len to its proper size in bytes. */
      long *get_rs232PortType(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232PortInSigNumber column and set
         ret_len to its proper size in bytes. */
      long *get_rs232PortInSigNumber(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232PortOutSigNumber column and set
         ret_len to its proper size in bytes. */
      long *get_rs232PortOutSigNumber(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232PortInSpeed column and set
         ret_len to its proper size in bytes. */
      long *get_rs232PortInSpeed(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232PortInSpeed column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232PortInSpeed(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232PortOutSpeed column and set
         ret_len to its proper size in bytes. */
      long *get_rs232PortOutSpeed(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232PortOutSpeed column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232PortOutSpeed(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232PortInFlowType column and set
         ret_len to its proper size in bytes. */
      long *get_rs232PortInFlowType(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232PortInFlowType column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232PortInFlowType(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232PortOutFlowType column and set
         ret_len to its proper size in bytes. */
      long *get_rs232PortOutFlowType(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232PortOutFlowType column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232PortOutFlowType(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
    

/** returns the first data point within the rs232AsyncPortTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
rs232AsyncPortTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232AsyncPortIndex data */, /** XXX: length of rs232AsyncPortIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as rs232AsyncPortTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
rs232AsyncPortTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232AsyncPortIndex data */, /** XXX: length of rs232AsyncPortIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
rs232AsyncPortTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
rs232AsyncPortTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table rs232AsyncPortTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the rs232AsyncPortIndex column and set
         ret_len to its proper size in bytes. */
      long *get_rs232AsyncPortIndex(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232AsyncPortBits column and set
         ret_len to its proper size in bytes. */
      long *get_rs232AsyncPortBits(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232AsyncPortBits column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232AsyncPortBits(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232AsyncPortStopBits column and set
         ret_len to its proper size in bytes. */
      long *get_rs232AsyncPortStopBits(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232AsyncPortStopBits column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232AsyncPortStopBits(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232AsyncPortParity column and set
         ret_len to its proper size in bytes. */
      long *get_rs232AsyncPortParity(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232AsyncPortParity column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232AsyncPortParity(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232AsyncPortAutobaud column and set
         ret_len to its proper size in bytes. */
      long *get_rs232AsyncPortAutobaud(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232AsyncPortAutobaud column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232AsyncPortAutobaud(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232AsyncPortParityErrs column and set
         ret_len to its proper size in bytes. */
      u_long *get_rs232AsyncPortParityErrs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232AsyncPortFramingErrs column and set
         ret_len to its proper size in bytes. */
      u_long *get_rs232AsyncPortFramingErrs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232AsyncPortOverrunErrs column and set
         ret_len to its proper size in bytes. */
      u_long *get_rs232AsyncPortOverrunErrs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
    

/** returns the first data point within the rs232SyncPortTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
rs232SyncPortTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232SyncPortIndex data */, /** XXX: length of rs232SyncPortIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as rs232SyncPortTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
rs232SyncPortTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232SyncPortIndex data */, /** XXX: length of rs232SyncPortIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
rs232SyncPortTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
rs232SyncPortTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table rs232SyncPortTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the rs232SyncPortIndex column and set
         ret_len to its proper size in bytes. */
      long *get_rs232SyncPortIndex(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortClockSource column and set
         ret_len to its proper size in bytes. */
      long *get_rs232SyncPortClockSource(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232SyncPortClockSource column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232SyncPortClockSource(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortFrameCheckErrs column and set
         ret_len to its proper size in bytes. */
      u_long *get_rs232SyncPortFrameCheckErrs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortTransmitUnderrunErrs column and set
         ret_len to its proper size in bytes. */
      u_long *get_rs232SyncPortTransmitUnderrunErrs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortReceiveOverrunErrs column and set
         ret_len to its proper size in bytes. */
      u_long *get_rs232SyncPortReceiveOverrunErrs(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortInterruptedFrames column and set
         ret_len to its proper size in bytes. */
      u_long *get_rs232SyncPortInterruptedFrames(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortAbortedFrames column and set
         ret_len to its proper size in bytes. */
      u_long *get_rs232SyncPortAbortedFrames(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortRole column and set
         ret_len to its proper size in bytes. */
      long *get_rs232SyncPortRole(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232SyncPortRole column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232SyncPortRole(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortEncoding column and set
         ret_len to its proper size in bytes. */
      long *get_rs232SyncPortEncoding(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232SyncPortEncoding column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232SyncPortEncoding(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortRTSControl column and set
         ret_len to its proper size in bytes. */
      long *get_rs232SyncPortRTSControl(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232SyncPortRTSControl column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232SyncPortRTSControl(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortRTSCTSDelay column and set
         ret_len to its proper size in bytes. */
      long *get_rs232SyncPortRTSCTSDelay(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232SyncPortRTSCTSDelay column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232SyncPortRTSCTSDelay(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortMode column and set
         ret_len to its proper size in bytes. */
      long *get_rs232SyncPortMode(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232SyncPortMode column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232SyncPortMode(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortIdlePattern column and set
         ret_len to its proper size in bytes. */
      long *get_rs232SyncPortIdlePattern(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232SyncPortIdlePattern column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232SyncPortIdlePattern(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the rs232SyncPortMinFlags column and set
         ret_len to its proper size in bytes. */
      long *get_rs232SyncPortMinFlags(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the rs232SyncPortMinFlags column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_rs232SyncPortMinFlags(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
    

/** returns the first data point within the rs232InSigTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
rs232InSigTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232InSigPortIndex data */, /** XXX: length of rs232InSigPortIndex data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232InSigName data */, /** XXX: length of rs232InSigName data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as rs232InSigTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
rs232InSigTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232InSigPortIndex data */, /** XXX: length of rs232InSigPortIndex data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232InSigName data */, /** XXX: length of rs232InSigName data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
rs232InSigTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
rs232InSigTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table rs232InSigTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the rs232InSigPortIndex column and set
         ret_len to its proper size in bytes. */
      long *get_rs232InSigPortIndex(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232InSigName column and set
         ret_len to its proper size in bytes. */
      long *get_rs232InSigName(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232InSigState column and set
         ret_len to its proper size in bytes. */
      long *get_rs232InSigState(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232InSigChanges column and set
         ret_len to its proper size in bytes. */
      u_long *get_rs232InSigChanges(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
    

/** returns the first data point within the rs232OutSigTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
rs232OutSigTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232OutSigPortIndex data */, /** XXX: length of rs232OutSigPortIndex data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232OutSigName data */, /** XXX: length of rs232OutSigName data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as rs232OutSigTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
rs232OutSigTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232OutSigPortIndex data */, /** XXX: length of rs232OutSigPortIndex data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: rs232OutSigName data */, /** XXX: length of rs232OutSigName data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
rs232OutSigTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
rs232OutSigTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table rs232OutSigTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the rs232OutSigPortIndex column and set
         ret_len to its proper size in bytes. */
      long *get_rs232OutSigPortIndex(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232OutSigName column and set
         ret_len to its proper size in bytes. */
      long *get_rs232OutSigName(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232OutSigState column and set
         ret_len to its proper size in bytes. */
      long *get_rs232OutSigState(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the rs232OutSigChanges column and set
         ret_len to its proper size in bytes. */
      u_long *get_rs232OutSigChanges(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
    

/** returns the first data point within the ifXTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
ifXTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifIndex data */, /** XXX: length of ifIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as ifXTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
ifXTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifIndex data */, /** XXX: length of ifIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
ifXTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
ifXTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table ifXTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the ifName column and set
         ret_len to its proper size in bytes. */
      char *get_ifName(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifInMulticastPkts column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifInMulticastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifInBroadcastPkts column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifInBroadcastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifOutMulticastPkts column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifOutMulticastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifOutBroadcastPkts column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifOutBroadcastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifHCInOctets column and set
         ret_len to its proper size in bytes. */
      U64 *get_ifHCInOctets(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifHCInUcastPkts column and set
         ret_len to its proper size in bytes. */
      U64 *get_ifHCInUcastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifHCInMulticastPkts column and set
         ret_len to its proper size in bytes. */
      U64 *get_ifHCInMulticastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifHCInBroadcastPkts column and set
         ret_len to its proper size in bytes. */
      U64 *get_ifHCInBroadcastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifHCOutOctets column and set
         ret_len to its proper size in bytes. */
      U64 *get_ifHCOutOctets(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifHCOutUcastPkts column and set
         ret_len to its proper size in bytes. */
      U64 *get_ifHCOutUcastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifHCOutMulticastPkts column and set
         ret_len to its proper size in bytes. */
      U64 *get_ifHCOutMulticastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifHCOutBroadcastPkts column and set
         ret_len to its proper size in bytes. */
      U64 *get_ifHCOutBroadcastPkts(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifLinkUpDownTrapEnable column and set
         ret_len to its proper size in bytes. */
      long *get_ifLinkUpDownTrapEnable(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ifLinkUpDownTrapEnable column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ifLinkUpDownTrapEnable(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ifHighSpeed column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifHighSpeed(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifPromiscuousMode column and set
         ret_len to its proper size in bytes. */
      long *get_ifPromiscuousMode(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ifPromiscuousMode column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ifPromiscuousMode(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ifConnectorPresent column and set
         ret_len to its proper size in bytes. */
      long *get_ifConnectorPresent(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifAlias column and set
         ret_len to its proper size in bytes. */
      char *get_ifAlias(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ifAlias column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ifAlias(void *data_context, char *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ifCounterDiscontinuityTime column and set
         ret_len to its proper size in bytes. */
      u_long *get_ifCounterDiscontinuityTime(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
    

/** returns the first data point within the ifStackTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
ifStackTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifStackHigherLayer data */, /** XXX: length of ifStackHigherLayer data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifStackLowerLayer data */, /** XXX: length of ifStackLowerLayer data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as ifStackTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
ifStackTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifStackHigherLayer data */, /** XXX: length of ifStackHigherLayer data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifStackLowerLayer data */, /** XXX: length of ifStackLowerLayer data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
ifStackTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
ifStackTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table ifStackTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the ifStackStatus column and set
         ret_len to its proper size in bytes. */
      long *get_ifStackStatus(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ifStackStatus column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ifStackStatus(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
    

/** returns the first data point within the ifTestTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
ifTestTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifIndex data */, /** XXX: length of ifIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as ifTestTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
ifTestTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifIndex data */, /** XXX: length of ifIndex data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
ifTestTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
ifTestTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table ifTestTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the ifTestId column and set
         ret_len to its proper size in bytes. */
      long *get_ifTestId(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ifTestId column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ifTestId(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ifTestStatus column and set
         ret_len to its proper size in bytes. */
      long *get_ifTestStatus(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ifTestStatus column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ifTestStatus(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ifTestType column and set
         ret_len to its proper size in bytes. */
      oid *get_ifTestType(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ifTestType column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ifTestType(void *data_context, oid *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ifTestResult column and set
         ret_len to its proper size in bytes. */
      long *get_ifTestResult(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifTestCode column and set
         ret_len to its proper size in bytes. */
      oid *get_ifTestCode(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: return a data pointer to the data for the ifTestOwner column and set
         ret_len to its proper size in bytes. */
      char *get_ifTestOwner(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ifTestOwner column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ifTestOwner(void *data_context, char *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
    

/** returns the first data point within the ifRcvAddressTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
ifRcvAddressTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifIndex data */, /** XXX: length of ifIndex data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifRcvAddressAddress data */, /** XXX: length of ifRcvAddressAddress data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as ifRcvAddressTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
ifRcvAddressTable_get_next_data_point(void **my_loop_context, void **my_data_context,
                         netsnmp_variable_list *put_index_data,
                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */;
    *my_data_context = /** XXX */;

    vptr = put_index_data;
    
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifIndex data */, /** XXX: length of ifIndex data */);
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: ifRcvAddressAddress data */, /** XXX: length of ifRcvAddressAddress data */);
    vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
ifRcvAddressTable_create_data_context(netsnmp_variable_list *index_data, int column) {
    return NULL; /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
ifRcvAddressTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*  */

    /* return no errors.  And there shouldn't be any!!!  Ever!!!  You
    should have checked the values long before this. */
    return SNMP_ERR_NOERROR;
}


/* User-defined data access functions (per column) for data in table ifRcvAddressTable */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the ifRcvAddressStatus column and set
         ret_len to its proper size in bytes. */
      long *get_ifRcvAddressStatus(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ifRcvAddressStatus column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ifRcvAddressStatus(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
/** XXX: return a data pointer to the data for the ifRcvAddressType column and set
         ret_len to its proper size in bytes. */
      long *get_ifRcvAddressType(void *data_context, size_t *ret_len) {
      return NULL; /** XXX: replace this with a pointer to a real value */
      }
/** XXX: Set the value of the ifRcvAddressType column and return
         SNMP_ERR_NOERROR on success
         SNMP_ERR_XXX     for SNMP deterministic error codes
         SNMP_ERR_GENERR  on generic failures (a last result response). */
      int set_ifRcvAddressType(void *data_context, long *val, size_t val_len) {
        return SNMP_ERR_NOERROR;  /** XXX: change if an error occurs */
      }
    

