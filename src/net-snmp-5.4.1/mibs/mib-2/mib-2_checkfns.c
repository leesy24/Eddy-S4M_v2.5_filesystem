/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.check_values.conf 9254 2004-01-12 00:43:46Z rstory $
 */

/********************************************************************
 *                       NOTE   NOTE   NOTE
 *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
 *   Modify the mib-2_checkfns_local.[ch] files insead so that you
 *   can regenerate this one as mib2c improvements are made.
 ********************************************************************/

/* standard headers */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include "mib-2_checkfns.h"
#include "mib-2_checkfns_local.h"
#include "mib-2_enums.h"

/** Decides if an incoming value for the ifAdminStatus mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ifAdminStatus(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case IFADMINSTATUS_UP:
      	  case IFADMINSTATUS_DOWN:
      	  case IFADMINSTATUS_TESTING:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ifAdminStatus_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the atIfIndex mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_atIfIndex(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_atIfIndex_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the atPhysAddress mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_atPhysAddress(int type, char *val, size_t val_len,
             char *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_OCTET_STR)
        return SNMP_ERR_WRONGTYPE;



    /** looks ok, call the local version of the same function. */
      return check_atPhysAddress_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the atNetAddress mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_atNetAddress(int type,  *val, size_t val_len,
              *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_COUNTER)
        return SNMP_ERR_WRONGTYPE;



    /** looks ok, call the local version of the same function. */
      return check_atNetAddress_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipRouteDest mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipRouteDest(int type, u_long *val, size_t val_len,
             u_long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_IPADDRESS)
        return SNMP_ERR_WRONGTYPE;



    /** looks ok, call the local version of the same function. */
      return check_ipRouteDest_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipRouteIfIndex mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipRouteIfIndex(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ipRouteIfIndex_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipRouteMetric1 mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipRouteMetric1(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ipRouteMetric1_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipRouteMetric2 mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipRouteMetric2(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ipRouteMetric2_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipRouteMetric3 mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipRouteMetric3(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ipRouteMetric3_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipRouteMetric4 mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipRouteMetric4(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ipRouteMetric4_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipRouteNextHop mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipRouteNextHop(int type, u_long *val, size_t val_len,
             u_long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_IPADDRESS)
        return SNMP_ERR_WRONGTYPE;



    /** looks ok, call the local version of the same function. */
      return check_ipRouteNextHop_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipRouteType mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipRouteType(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case IPROUTETYPE_OTHER:
      	  case IPROUTETYPE_INVALID:
      	  case IPROUTETYPE_DIRECT:
      	  case IPROUTETYPE_INDIRECT:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ipRouteType_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipRouteAge mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipRouteAge(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ipRouteAge_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipRouteMask mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipRouteMask(int type, u_long *val, size_t val_len,
             u_long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_IPADDRESS)
        return SNMP_ERR_WRONGTYPE;



    /** looks ok, call the local version of the same function. */
      return check_ipRouteMask_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipRouteMetric5 mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipRouteMetric5(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ipRouteMetric5_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipNetToMediaIfIndex mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipNetToMediaIfIndex(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ipNetToMediaIfIndex_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipNetToMediaPhysAddress mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipNetToMediaPhysAddress(int type, char *val, size_t val_len,
             char *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_OCTET_STR)
        return SNMP_ERR_WRONGTYPE;



    /** looks ok, call the local version of the same function. */
      return check_ipNetToMediaPhysAddress_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipNetToMediaNetAddress mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipNetToMediaNetAddress(int type, u_long *val, size_t val_len,
             u_long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_IPADDRESS)
        return SNMP_ERR_WRONGTYPE;



    /** looks ok, call the local version of the same function. */
      return check_ipNetToMediaNetAddress_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ipNetToMediaType mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ipNetToMediaType(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case IPNETTOMEDIATYPE_OTHER:
      	  case IPNETTOMEDIATYPE_INVALID:
      	  case IPNETTOMEDIATYPE_DYNAMIC:
      	  case IPNETTOMEDIATYPE_STATIC:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ipNetToMediaType_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the tcpConnState mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_tcpConnState(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case TCPCONNSTATE_CLOSED:
      	  case TCPCONNSTATE_LISTEN:
      	  case TCPCONNSTATE_SYNSENT:
      	  case TCPCONNSTATE_SYNRECEIVED:
      	  case TCPCONNSTATE_ESTABLISHED:
      	  case TCPCONNSTATE_FINWAIT1:
      	  case TCPCONNSTATE_FINWAIT2:
      	  case TCPCONNSTATE_CLOSEWAIT:
      	  case TCPCONNSTATE_LASTACK:
      	  case TCPCONNSTATE_CLOSING:
      	  case TCPCONNSTATE_TIMEWAIT:
      	  case TCPCONNSTATE_DELETETCB:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_tcpConnState_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the egpNeighEventTrigger mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_egpNeighEventTrigger(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case EGPNEIGHEVENTTRIGGER_START:
      	  case EGPNEIGHEVENTTRIGGER_STOP:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_egpNeighEventTrigger_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232PortInSpeed mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232PortInSpeed(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232PortInSpeed_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232PortOutSpeed mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232PortOutSpeed(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232PortOutSpeed_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232PortInFlowType mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232PortInFlowType(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case RS232PORTINFLOWTYPE_NONE:
      	  case RS232PORTINFLOWTYPE_CTSRTS:
      	  case RS232PORTINFLOWTYPE_DSRDTR:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232PortInFlowType_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232PortOutFlowType mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232PortOutFlowType(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case RS232PORTOUTFLOWTYPE_NONE:
      	  case RS232PORTOUTFLOWTYPE_CTSRTS:
      	  case RS232PORTOUTFLOWTYPE_DSRDTR:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232PortOutFlowType_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232AsyncPortBits mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232AsyncPortBits(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;
    /** Check the ranges of the passed value for legality */
	    if (
	       !(*val >= 5 && *val <= 8)
            ) {
            return SNMP_ERR_WRONGVALUE;
            }


    /** looks ok, call the local version of the same function. */
      return check_rs232AsyncPortBits_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232AsyncPortStopBits mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232AsyncPortStopBits(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case RS232ASYNCPORTSTOPBITS_ONE:
      	  case RS232ASYNCPORTSTOPBITS_TWO:
      	  case RS232ASYNCPORTSTOPBITS_ONEANDHALF:
      	  case RS232ASYNCPORTSTOPBITS_DYNAMIC:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232AsyncPortStopBits_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232AsyncPortParity mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232AsyncPortParity(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case RS232ASYNCPORTPARITY_NONE:
      	  case RS232ASYNCPORTPARITY_ODD:
      	  case RS232ASYNCPORTPARITY_EVEN:
      	  case RS232ASYNCPORTPARITY_MARK:
      	  case RS232ASYNCPORTPARITY_SPACE:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232AsyncPortParity_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232AsyncPortAutobaud mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232AsyncPortAutobaud(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case RS232ASYNCPORTAUTOBAUD_ENABLED:
      	  case RS232ASYNCPORTAUTOBAUD_DISABLED:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232AsyncPortAutobaud_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232SyncPortClockSource mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232SyncPortClockSource(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case RS232SYNCPORTCLOCKSOURCE_INTERNAL:
      	  case RS232SYNCPORTCLOCKSOURCE_EXTERNAL:
      	  case RS232SYNCPORTCLOCKSOURCE_SPLIT:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232SyncPortClockSource_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232SyncPortRole mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232SyncPortRole(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case RS232SYNCPORTROLE_DTE:
      	  case RS232SYNCPORTROLE_DCE:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232SyncPortRole_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232SyncPortEncoding mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232SyncPortEncoding(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case RS232SYNCPORTENCODING_NRZ:
      	  case RS232SYNCPORTENCODING_NRZI:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232SyncPortEncoding_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232SyncPortRTSControl mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232SyncPortRTSControl(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case RS232SYNCPORTRTSCONTROL_CONTROLLED:
      	  case RS232SYNCPORTRTSCONTROL_CONSTANT:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232SyncPortRTSControl_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232SyncPortRTSCTSDelay mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232SyncPortRTSCTSDelay(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232SyncPortRTSCTSDelay_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232SyncPortMode mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232SyncPortMode(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case RS232SYNCPORTMODE_FDX:
      	  case RS232SYNCPORTMODE_HDX:
      	  case RS232SYNCPORTMODE_SIMPLEX_RECEIVE:
      	  case RS232SYNCPORTMODE_SIMPLEX_SEND:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232SyncPortMode_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232SyncPortIdlePattern mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232SyncPortIdlePattern(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case RS232SYNCPORTIDLEPATTERN_MARK:
      	  case RS232SYNCPORTIDLEPATTERN_SPACE:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232SyncPortIdlePattern_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the rs232SyncPortMinFlags mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_rs232SyncPortMinFlags(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_rs232SyncPortMinFlags_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ifLinkUpDownTrapEnable mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ifLinkUpDownTrapEnable(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case IFLINKUPDOWNTRAPENABLE_ENABLED:
      	  case IFLINKUPDOWNTRAPENABLE_DISABLED:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ifLinkUpDownTrapEnable_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ifPromiscuousMode mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ifPromiscuousMode(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case IFPROMISCUOUSMODE_TRUE:
      	  case IFPROMISCUOUSMODE_FALSE:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ifPromiscuousMode_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ifAlias mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ifAlias(int type, char *val, size_t val_len,
             char *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_OCTET_STR)
        return SNMP_ERR_WRONGTYPE;

    /** Check the ranges of the passed value for legality */
	    if (
	       !(val_len >= 0 && val_len <= 64)
            ) {
            return SNMP_ERR_WRONGVALUE;
            }


    /** looks ok, call the local version of the same function. */
      return check_ifAlias_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ifStackStatus mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ifStackStatus(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case IFSTACKSTATUS_ACTIVE:
      	  case IFSTACKSTATUS_NOTINSERVICE:
      	  case IFSTACKSTATUS_NOTREADY:
      	  case IFSTACKSTATUS_CREATEANDGO:
      	  case IFSTACKSTATUS_CREATEANDWAIT:
      	  case IFSTACKSTATUS_DESTROY:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;

      if (ret = check_rowstatus_transition((old_val) ? *old_val : RS_NONEXISTENT, *val))
          return ret;

    /** looks ok, call the local version of the same function. */
      return check_ifStackStatus_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ifTestId mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ifTestId(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

	ret = SNMP_ERR_NOERROR;
    /** Check the ranges of the passed value for legality */
	    if (
	       !(*val >= 0 && *val <= 2147483647)
            ) {
            return SNMP_ERR_WRONGVALUE;
            }


    /** looks ok, call the local version of the same function. */
      return check_ifTestId_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ifTestStatus mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ifTestStatus(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case IFTESTSTATUS_NOTINUSE:
      	  case IFTESTSTATUS_INUSE:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ifTestStatus_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ifTestType mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ifTestType(int type, oid *val, size_t val_len,
             oid *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_OBJECT_ID)
        return SNMP_ERR_WRONGTYPE;



    /** looks ok, call the local version of the same function. */
      return check_ifTestType_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ifTestOwner mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ifTestOwner(int type, char *val, size_t val_len,
             char *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_OCTET_STR)
        return SNMP_ERR_WRONGTYPE;

    /** Check the ranges of the passed value for legality */
	    if (
	       !(val_len >= 0 && val_len <= 255)
            ) {
            return SNMP_ERR_WRONGVALUE;
            }


    /** looks ok, call the local version of the same function. */
      return check_ifTestOwner_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ifRcvAddressStatus mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ifRcvAddressStatus(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case IFRCVADDRESSSTATUS_ACTIVE:
      	  case IFRCVADDRESSSTATUS_NOTINSERVICE:
      	  case IFRCVADDRESSSTATUS_NOTREADY:
      	  case IFRCVADDRESSSTATUS_CREATEANDGO:
      	  case IFRCVADDRESSSTATUS_CREATEANDWAIT:
      	  case IFRCVADDRESSSTATUS_DESTROY:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;

      if (ret = check_rowstatus_transition((old_val) ? *old_val : RS_NONEXISTENT, *val))
          return ret;

    /** looks ok, call the local version of the same function. */
      return check_ifRcvAddressStatus_local(type, val, val_len, old_val, old_val_len);
    }
/** Decides if an incoming value for the ifRcvAddressType mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_ifRcvAddressType(int type, long *val, size_t val_len,
             long *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != ASN_INTEGER)
        return SNMP_ERR_WRONGTYPE;

    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
      	  case IFRCVADDRESSTYPE_OTHER:
      	  case IFRCVADDRESSTYPE_VOLATILE:
      	  case IFRCVADDRESSTYPE_NONVOLATILE:
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
	ret = SNMP_ERR_NOERROR;


    /** looks ok, call the local version of the same function. */
      return check_ifRcvAddressType_local(type, val, val_len, old_val, old_val_len);
    }
