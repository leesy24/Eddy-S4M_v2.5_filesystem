/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate_access.conf 15179 2006-09-08 15:44:37Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "mib-2.h"
#include "mib-2_checkfns.h"
#include "mib-2_access.h"

static netsnmp_oid_stash_node *undoStorage = NULL;
static netsnmp_oid_stash_node *commitStorage = NULL;

struct undoInfo {
   void *ptr;
   size_t len;
};

struct commitInfo {
   void *data_context;
   int have_committed;
   int new_row;
};

void
mib-2_free_undoInfo(void *vptr) {
    struct undoInfo *ui = vptr;
    if (!ui)
        return;
    SNMP_FREE(ui->ptr);
    SNMP_FREE(ui);
}

/** Initialize the sysORTable table by defining its contents and how it's structured */
void
initialize_table_sysORTable(void)
{
    static oid sysORTable_oid[] = {1,3,6,1,2,1,1,9};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("sysORTable",
                                             sysORTable_handler,
                                             sysORTable_oid,
                                             OID_LENGTH(sysORTable_oid),
                                             HANDLER_CAN_RONLY
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_sysORTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: sysORIndex */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 2;
    table_info->max_column = 4;

    /** iterator access routines */
    iinfo->get_first_data_point = sysORTable_get_first_data_point;
    iinfo->get_next_data_point = sysORTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = sysORTable_context_convert_function;
    iinfo->free_data_context = sysORTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = sysORTable_loop_free;
    iinfo->free_loop_context_at_end = sysORTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_sysORTable",
                "Registering table sysORTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the ifTable table by defining its contents and how it's structured */
void
initialize_table_ifTable(void)
{
    static oid ifTable_oid[] = {1,3,6,1,2,1,2,2};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("ifTable",
                                             ifTable_handler,
                                             ifTable_oid,
                                             OID_LENGTH(ifTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_ifTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: ifIndex */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 22;

    /** iterator access routines */
    iinfo->get_first_data_point = ifTable_get_first_data_point;
    iinfo->get_next_data_point = ifTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = ifTable_context_convert_function;
    iinfo->free_data_context = ifTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = ifTable_loop_free;
    iinfo->free_loop_context_at_end = ifTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_ifTable",
                "Registering table ifTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the atTable table by defining its contents and how it's structured */
void
initialize_table_atTable(void)
{
    static oid atTable_oid[] = {1,3,6,1,2,1,3,1};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("atTable",
                                             atTable_handler,
                                             atTable_oid,
                                             OID_LENGTH(atTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_atTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: atIfIndex */
                                  ASN_COUNTER, /** index: atNetAddress */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 3;

    /** iterator access routines */
    iinfo->get_first_data_point = atTable_get_first_data_point;
    iinfo->get_next_data_point = atTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = atTable_context_convert_function;
    iinfo->free_data_context = atTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = atTable_loop_free;
    iinfo->free_loop_context_at_end = atTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atTable",
                "Registering table atTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the ipAddrTable table by defining its contents and how it's structured */
void
initialize_table_ipAddrTable(void)
{
    static oid ipAddrTable_oid[] = {1,3,6,1,2,1,4,20};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("ipAddrTable",
                                             ipAddrTable_handler,
                                             ipAddrTable_oid,
                                             OID_LENGTH(ipAddrTable_oid),
                                             HANDLER_CAN_RONLY
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_ipAddrTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_IPADDRESS, /** index: ipAdEntAddr */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 5;

    /** iterator access routines */
    iinfo->get_first_data_point = ipAddrTable_get_first_data_point;
    iinfo->get_next_data_point = ipAddrTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = ipAddrTable_context_convert_function;
    iinfo->free_data_context = ipAddrTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = ipAddrTable_loop_free;
    iinfo->free_loop_context_at_end = ipAddrTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_ipAddrTable",
                "Registering table ipAddrTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the ipRouteTable table by defining its contents and how it's structured */
void
initialize_table_ipRouteTable(void)
{
    static oid ipRouteTable_oid[] = {1,3,6,1,2,1,4,21};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("ipRouteTable",
                                             ipRouteTable_handler,
                                             ipRouteTable_oid,
                                             OID_LENGTH(ipRouteTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_ipRouteTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_IPADDRESS, /** index: ipRouteDest */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 13;

    /** iterator access routines */
    iinfo->get_first_data_point = ipRouteTable_get_first_data_point;
    iinfo->get_next_data_point = ipRouteTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = ipRouteTable_context_convert_function;
    iinfo->free_data_context = ipRouteTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = ipRouteTable_loop_free;
    iinfo->free_loop_context_at_end = ipRouteTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_ipRouteTable",
                "Registering table ipRouteTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the ipNetToMediaTable table by defining its contents and how it's structured */
void
initialize_table_ipNetToMediaTable(void)
{
    static oid ipNetToMediaTable_oid[] = {1,3,6,1,2,1,4,22};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("ipNetToMediaTable",
                                             ipNetToMediaTable_handler,
                                             ipNetToMediaTable_oid,
                                             OID_LENGTH(ipNetToMediaTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_ipNetToMediaTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: ipNetToMediaIfIndex */
                                  ASN_IPADDRESS, /** index: ipNetToMediaNetAddress */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 4;

    /** iterator access routines */
    iinfo->get_first_data_point = ipNetToMediaTable_get_first_data_point;
    iinfo->get_next_data_point = ipNetToMediaTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = ipNetToMediaTable_context_convert_function;
    iinfo->free_data_context = ipNetToMediaTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = ipNetToMediaTable_loop_free;
    iinfo->free_loop_context_at_end = ipNetToMediaTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_ipNetToMediaTable",
                "Registering table ipNetToMediaTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the tcpConnTable table by defining its contents and how it's structured */
void
initialize_table_tcpConnTable(void)
{
    static oid tcpConnTable_oid[] = {1,3,6,1,2,1,6,13};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("tcpConnTable",
                                             tcpConnTable_handler,
                                             tcpConnTable_oid,
                                             OID_LENGTH(tcpConnTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_tcpConnTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_IPADDRESS, /** index: tcpConnLocalAddress */
                                  ASN_INTEGER, /** index: tcpConnLocalPort */
                                  ASN_IPADDRESS, /** index: tcpConnRemAddress */
                                  ASN_INTEGER, /** index: tcpConnRemPort */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 5;

    /** iterator access routines */
    iinfo->get_first_data_point = tcpConnTable_get_first_data_point;
    iinfo->get_next_data_point = tcpConnTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = tcpConnTable_context_convert_function;
    iinfo->free_data_context = tcpConnTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = tcpConnTable_loop_free;
    iinfo->free_loop_context_at_end = tcpConnTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_tcpConnTable",
                "Registering table tcpConnTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the udpTable table by defining its contents and how it's structured */
void
initialize_table_udpTable(void)
{
    static oid udpTable_oid[] = {1,3,6,1,2,1,7,5};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("udpTable",
                                             udpTable_handler,
                                             udpTable_oid,
                                             OID_LENGTH(udpTable_oid),
                                             HANDLER_CAN_RONLY
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_udpTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_IPADDRESS, /** index: udpLocalAddress */
                                  ASN_INTEGER, /** index: udpLocalPort */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 2;

    /** iterator access routines */
    iinfo->get_first_data_point = udpTable_get_first_data_point;
    iinfo->get_next_data_point = udpTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = udpTable_context_convert_function;
    iinfo->free_data_context = udpTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = udpTable_loop_free;
    iinfo->free_loop_context_at_end = udpTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_udpTable",
                "Registering table udpTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the egpNeighTable table by defining its contents and how it's structured */
void
initialize_table_egpNeighTable(void)
{
    static oid egpNeighTable_oid[] = {1,3,6,1,2,1,8,5};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("egpNeighTable",
                                             egpNeighTable_handler,
                                             egpNeighTable_oid,
                                             OID_LENGTH(egpNeighTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_egpNeighTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_IPADDRESS, /** index: egpNeighAddr */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 15;

    /** iterator access routines */
    iinfo->get_first_data_point = egpNeighTable_get_first_data_point;
    iinfo->get_next_data_point = egpNeighTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = egpNeighTable_context_convert_function;
    iinfo->free_data_context = egpNeighTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = egpNeighTable_loop_free;
    iinfo->free_loop_context_at_end = egpNeighTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_egpNeighTable",
                "Registering table egpNeighTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the rs232PortTable table by defining its contents and how it's structured */
void
initialize_table_rs232PortTable(void)
{
    static oid rs232PortTable_oid[] = {1,3,6,1,2,1,10,33,2};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("rs232PortTable",
                                             rs232PortTable_handler,
                                             rs232PortTable_oid,
                                             OID_LENGTH(rs232PortTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_rs232PortTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: rs232PortIndex */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 8;

    /** iterator access routines */
    iinfo->get_first_data_point = rs232PortTable_get_first_data_point;
    iinfo->get_next_data_point = rs232PortTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = rs232PortTable_context_convert_function;
    iinfo->free_data_context = rs232PortTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = rs232PortTable_loop_free;
    iinfo->free_loop_context_at_end = rs232PortTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_rs232PortTable",
                "Registering table rs232PortTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the rs232AsyncPortTable table by defining its contents and how it's structured */
void
initialize_table_rs232AsyncPortTable(void)
{
    static oid rs232AsyncPortTable_oid[] = {1,3,6,1,2,1,10,33,3};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("rs232AsyncPortTable",
                                             rs232AsyncPortTable_handler,
                                             rs232AsyncPortTable_oid,
                                             OID_LENGTH(rs232AsyncPortTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_rs232AsyncPortTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: rs232AsyncPortIndex */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 8;

    /** iterator access routines */
    iinfo->get_first_data_point = rs232AsyncPortTable_get_first_data_point;
    iinfo->get_next_data_point = rs232AsyncPortTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = rs232AsyncPortTable_context_convert_function;
    iinfo->free_data_context = rs232AsyncPortTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = rs232AsyncPortTable_loop_free;
    iinfo->free_loop_context_at_end = rs232AsyncPortTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_rs232AsyncPortTable",
                "Registering table rs232AsyncPortTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the rs232SyncPortTable table by defining its contents and how it's structured */
void
initialize_table_rs232SyncPortTable(void)
{
    static oid rs232SyncPortTable_oid[] = {1,3,6,1,2,1,10,33,4};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("rs232SyncPortTable",
                                             rs232SyncPortTable_handler,
                                             rs232SyncPortTable_oid,
                                             OID_LENGTH(rs232SyncPortTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_rs232SyncPortTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: rs232SyncPortIndex */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 14;

    /** iterator access routines */
    iinfo->get_first_data_point = rs232SyncPortTable_get_first_data_point;
    iinfo->get_next_data_point = rs232SyncPortTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = rs232SyncPortTable_context_convert_function;
    iinfo->free_data_context = rs232SyncPortTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = rs232SyncPortTable_loop_free;
    iinfo->free_loop_context_at_end = rs232SyncPortTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_rs232SyncPortTable",
                "Registering table rs232SyncPortTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the rs232InSigTable table by defining its contents and how it's structured */
void
initialize_table_rs232InSigTable(void)
{
    static oid rs232InSigTable_oid[] = {1,3,6,1,2,1,10,33,5};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("rs232InSigTable",
                                             rs232InSigTable_handler,
                                             rs232InSigTable_oid,
                                             OID_LENGTH(rs232InSigTable_oid),
                                             HANDLER_CAN_RONLY
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_rs232InSigTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: rs232InSigPortIndex */
                                  ASN_INTEGER, /** index: rs232InSigName */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 4;

    /** iterator access routines */
    iinfo->get_first_data_point = rs232InSigTable_get_first_data_point;
    iinfo->get_next_data_point = rs232InSigTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = rs232InSigTable_context_convert_function;
    iinfo->free_data_context = rs232InSigTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = rs232InSigTable_loop_free;
    iinfo->free_loop_context_at_end = rs232InSigTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_rs232InSigTable",
                "Registering table rs232InSigTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the rs232OutSigTable table by defining its contents and how it's structured */
void
initialize_table_rs232OutSigTable(void)
{
    static oid rs232OutSigTable_oid[] = {1,3,6,1,2,1,10,33,6};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("rs232OutSigTable",
                                             rs232OutSigTable_handler,
                                             rs232OutSigTable_oid,
                                             OID_LENGTH(rs232OutSigTable_oid),
                                             HANDLER_CAN_RONLY
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_rs232OutSigTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: rs232OutSigPortIndex */
                                  ASN_INTEGER, /** index: rs232OutSigName */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 4;

    /** iterator access routines */
    iinfo->get_first_data_point = rs232OutSigTable_get_first_data_point;
    iinfo->get_next_data_point = rs232OutSigTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = rs232OutSigTable_context_convert_function;
    iinfo->free_data_context = rs232OutSigTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = rs232OutSigTable_loop_free;
    iinfo->free_loop_context_at_end = rs232OutSigTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_rs232OutSigTable",
                "Registering table rs232OutSigTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the ifXTable table by defining its contents and how it's structured */
void
initialize_table_ifXTable(void)
{
    static oid ifXTable_oid[] = {1,3,6,1,2,1,31,1,1};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("ifXTable",
                                             ifXTable_handler,
                                             ifXTable_oid,
                                             OID_LENGTH(ifXTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_ifXTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: ifIndex */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 19;

    /** iterator access routines */
    iinfo->get_first_data_point = ifXTable_get_first_data_point;
    iinfo->get_next_data_point = ifXTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = ifXTable_context_convert_function;
    iinfo->free_data_context = ifXTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = ifXTable_loop_free;
    iinfo->free_loop_context_at_end = ifXTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_ifXTable",
                "Registering table ifXTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the ifStackTable table by defining its contents and how it's structured */
void
initialize_table_ifStackTable(void)
{
    static oid ifStackTable_oid[] = {1,3,6,1,2,1,31,1,2};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("ifStackTable",
                                             ifStackTable_handler,
                                             ifStackTable_oid,
                                             OID_LENGTH(ifStackTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_ifStackTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: ifStackHigherLayer */
                                  ASN_INTEGER, /** index: ifStackLowerLayer */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 3;
    table_info->max_column = 3;

    /** iterator access routines */
    iinfo->get_first_data_point = ifStackTable_get_first_data_point;
    iinfo->get_next_data_point = ifStackTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = ifStackTable_context_convert_function;
    iinfo->free_data_context = ifStackTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = ifStackTable_loop_free;
    iinfo->free_loop_context_at_end = ifStackTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_ifStackTable",
                "Registering table ifStackTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the ifTestTable table by defining its contents and how it's structured */
void
initialize_table_ifTestTable(void)
{
    static oid ifTestTable_oid[] = {1,3,6,1,2,1,31,1,3};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("ifTestTable",
                                             ifTestTable_handler,
                                             ifTestTable_oid,
                                             OID_LENGTH(ifTestTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_ifTestTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: ifIndex */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 6;

    /** iterator access routines */
    iinfo->get_first_data_point = ifTestTable_get_first_data_point;
    iinfo->get_next_data_point = ifTestTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = ifTestTable_context_convert_function;
    iinfo->free_data_context = ifTestTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = ifTestTable_loop_free;
    iinfo->free_loop_context_at_end = ifTestTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_ifTestTable",
                "Registering table ifTestTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}
/** Initialize the ifRcvAddressTable table by defining its contents and how it's structured */
void
initialize_table_ifRcvAddressTable(void)
{
    static oid ifRcvAddressTable_oid[] = {1,3,6,1,2,1,31,1,4};
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("ifRcvAddressTable",
                                             ifRcvAddressTable_handler,
                                             ifRcvAddressTable_oid,
                                             OID_LENGTH(ifRcvAddressTable_oid),
                                             HANDLER_CAN_RWRITE
                                             );
            
    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_ifRcvAddressTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
                                  ASN_INTEGER, /** index: ifIndex */
                                  ASN_OCTET_STR, /** index: ifRcvAddressAddress */
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 2;
    table_info->max_column = 3;

    /** iterator access routines */
    iinfo->get_first_data_point = ifRcvAddressTable_get_first_data_point;
    iinfo->get_next_data_point = ifRcvAddressTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = ifRcvAddressTable_context_convert_function;
    iinfo->free_data_context = ifRcvAddressTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = ifRcvAddressTable_loop_free;
    iinfo->free_loop_context_at_end = ifRcvAddressTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_ifRcvAddressTable",
                "Registering table ifRcvAddressTable as a table iterator\n"));		 
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** Initializes the mib-2 module */
void
init_mib-2(void)
{

  /** here we initialize all the tables we're planning on supporting */
    initialize_table_sysORTable();
    initialize_table_ifTable();
    initialize_table_atTable();
    initialize_table_ipAddrTable();
    initialize_table_ipRouteTable();
    initialize_table_ipNetToMediaTable();
    initialize_table_tcpConnTable();
    initialize_table_udpTable();
    initialize_table_egpNeighTable();
    initialize_table_rs232PortTable();
    initialize_table_rs232AsyncPortTable();
    initialize_table_rs232SyncPortTable();
    initialize_table_rs232InSigTable();
    initialize_table_rs232OutSigTable();
    initialize_table_ifXTable();
    initialize_table_ifStackTable();
    initialize_table_ifTestTable();
    initialize_table_ifRcvAddressTable();
}

/** handles requests for the sysORTable table, if anything else needs to be done */
int
sysORTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_SYSORID:
                            {
                                oid *retval;
                                size_t retval_len = 0;
                                retval = get_sysORID(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_SYSORDESCR:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                retval = get_sysORDescr(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_SYSORUPTIME:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_sysORUpTime(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_TIMETICKS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in sysORTable_handler: unknown column\n");
                }
                break;


            default:
                snmp_log(LOG_ERR, "problem encountered in sysORTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the ifTable table, if anything else needs to be done */
int
ifTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_IFINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifIndex(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFDESCR:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                retval = get_ifDescr(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFTYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifType(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFMTU:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifMtu(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFSPEED:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifSpeed(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_GAUGE,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFPHYSADDRESS:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                retval = get_ifPhysAddress(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFADMINSTATUS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifAdminStatus(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFOPERSTATUS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifOperStatus(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFLASTCHANGE:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifLastChange(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_TIMETICKS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFINOCTETS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifInOctets(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFINUCASTPKTS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifInUcastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFINNUCASTPKTS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifInNUcastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFINDISCARDS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifInDiscards(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFINERRORS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifInErrors(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFINUNKNOWNPROTOS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifInUnknownProtos(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFOUTOCTETS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifOutOctets(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFOUTUCASTPKTS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifOutUcastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFOUTNUCASTPKTS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifOutNUcastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFOUTDISCARDS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifOutDiscards(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFOUTERRORS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifOutErrors(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFOUTQLEN:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifOutQLen(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_GAUGE,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFSPECIFIC:
                            {
                                oid *retval;
                                size_t retval_len = 0;
                                retval = get_ifSpecific(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in ifTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = ifTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_IFADMINSTATUS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ifAdminStatus(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ifAdminStatus(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IFADMINSTATUS:
                            {
                                int ret;
                                ret = set_ifAdminStatus(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    ifTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IFADMINSTATUS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ifAdminStatus(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in ifTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the atTable table, if anything else needs to be done */
int
atTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_ATIFINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_atIfIndex(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_ATPHYSADDRESS:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                retval = get_atPhysAddress(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_ATNETADDRESS:
                            {
                                 *retval;
                                size_t retval_len = 0;
                                retval = get_atNetAddress(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in atTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = atTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_ATIFINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_atIfIndex(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_atIfIndex(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_ATPHYSADDRESS:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_atPhysAddress(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_atPhysAddress(request->requestvb->type,
                                                   (char *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_ATNETADDRESS:
                            {
                                 *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_atNetAddress(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_atNetAddress(request->requestvb->type,
                                                   ( *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_ATIFINDEX:
                            {
                                int ret;
                                ret = set_atIfIndex(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_ATPHYSADDRESS:
                            {
                                int ret;
                                ret = set_atPhysAddress(ci->data_context,
                                             (char *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_ATNETADDRESS:
                            {
                                int ret;
                                ret = set_atNetAddress(ci->data_context,
                                             ( *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    atTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_ATIFINDEX:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_atIfIndex(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_ATPHYSADDRESS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_atPhysAddress(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_ATNETADDRESS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_atNetAddress(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in atTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the ipAddrTable table, if anything else needs to be done */
int
ipAddrTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_IPADENTADDR:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ipAdEntAddr(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_IPADDRESS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPADENTIFINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipAdEntIfIndex(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPADENTNETMASK:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ipAdEntNetMask(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_IPADDRESS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPADENTBCASTADDR:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipAdEntBcastAddr(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPADENTREASMMAXSIZE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipAdEntReasmMaxSize(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in ipAddrTable_handler: unknown column\n");
                }
                break;


            default:
                snmp_log(LOG_ERR, "problem encountered in ipAddrTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the ipRouteTable table, if anything else needs to be done */
int
ipRouteTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_IPROUTEDEST:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteDest(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_IPADDRESS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTEIFINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteIfIndex(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTEMETRIC1:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteMetric1(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTEMETRIC2:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteMetric2(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTEMETRIC3:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteMetric3(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTEMETRIC4:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteMetric4(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTENEXTHOP:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteNextHop(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_IPADDRESS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTETYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteType(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTEPROTO:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteProto(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTEAGE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteAge(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTEMASK:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteMask(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_IPADDRESS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTEMETRIC5:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteMetric5(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPROUTEINFO:
                            {
                                oid *retval;
                                size_t retval_len = 0;
                                retval = get_ipRouteInfo(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in ipRouteTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = ipRouteTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_IPROUTEDEST:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipRouteDest(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipRouteDest(request->requestvb->type,
                                                   (u_long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPROUTEIFINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipRouteIfIndex(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipRouteIfIndex(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC1:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipRouteMetric1(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipRouteMetric1(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC2:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipRouteMetric2(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipRouteMetric2(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC3:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipRouteMetric3(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipRouteMetric3(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC4:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipRouteMetric4(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipRouteMetric4(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPROUTENEXTHOP:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipRouteNextHop(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipRouteNextHop(request->requestvb->type,
                                                   (u_long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPROUTETYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipRouteType(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipRouteType(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPROUTEAGE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipRouteAge(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipRouteAge(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPROUTEMASK:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipRouteMask(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipRouteMask(request->requestvb->type,
                                                   (u_long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC5:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipRouteMetric5(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipRouteMetric5(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IPROUTEDEST:
                            {
                                int ret;
                                ret = set_ipRouteDest(ci->data_context,
                                             (u_long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEIFINDEX:
                            {
                                int ret;
                                ret = set_ipRouteIfIndex(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC1:
                            {
                                int ret;
                                ret = set_ipRouteMetric1(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC2:
                            {
                                int ret;
                                ret = set_ipRouteMetric2(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC3:
                            {
                                int ret;
                                ret = set_ipRouteMetric3(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC4:
                            {
                                int ret;
                                ret = set_ipRouteMetric4(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPROUTENEXTHOP:
                            {
                                int ret;
                                ret = set_ipRouteNextHop(ci->data_context,
                                             (u_long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPROUTETYPE:
                            {
                                int ret;
                                ret = set_ipRouteType(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEAGE:
                            {
                                int ret;
                                ret = set_ipRouteAge(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMASK:
                            {
                                int ret;
                                ret = set_ipRouteMask(ci->data_context,
                                             (u_long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC5:
                            {
                                int ret;
                                ret = set_ipRouteMetric5(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    ipRouteTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IPROUTEDEST:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipRouteDest(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEIFINDEX:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipRouteIfIndex(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC1:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipRouteMetric1(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC2:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipRouteMetric2(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC3:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipRouteMetric3(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC4:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipRouteMetric4(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPROUTENEXTHOP:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipRouteNextHop(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPROUTETYPE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipRouteType(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEAGE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipRouteAge(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMASK:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipRouteMask(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPROUTEMETRIC5:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipRouteMetric5(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in ipRouteTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the ipNetToMediaTable table, if anything else needs to be done */
int
ipNetToMediaTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_IPNETTOMEDIAIFINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipNetToMediaIfIndex(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPNETTOMEDIAPHYSADDRESS:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                retval = get_ipNetToMediaPhysAddress(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPNETTOMEDIANETADDRESS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ipNetToMediaNetAddress(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_IPADDRESS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IPNETTOMEDIATYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ipNetToMediaType(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in ipNetToMediaTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = ipNetToMediaTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_IPNETTOMEDIAIFINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipNetToMediaIfIndex(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipNetToMediaIfIndex(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPNETTOMEDIAPHYSADDRESS:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipNetToMediaPhysAddress(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipNetToMediaPhysAddress(request->requestvb->type,
                                                   (char *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPNETTOMEDIANETADDRESS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipNetToMediaNetAddress(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipNetToMediaNetAddress(request->requestvb->type,
                                                   (u_long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IPNETTOMEDIATYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ipNetToMediaType(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ipNetToMediaType(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IPNETTOMEDIAIFINDEX:
                            {
                                int ret;
                                ret = set_ipNetToMediaIfIndex(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPNETTOMEDIAPHYSADDRESS:
                            {
                                int ret;
                                ret = set_ipNetToMediaPhysAddress(ci->data_context,
                                             (char *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPNETTOMEDIANETADDRESS:
                            {
                                int ret;
                                ret = set_ipNetToMediaNetAddress(ci->data_context,
                                             (u_long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IPNETTOMEDIATYPE:
                            {
                                int ret;
                                ret = set_ipNetToMediaType(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    ipNetToMediaTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IPNETTOMEDIAIFINDEX:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipNetToMediaIfIndex(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPNETTOMEDIAPHYSADDRESS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipNetToMediaPhysAddress(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPNETTOMEDIANETADDRESS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipNetToMediaNetAddress(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IPNETTOMEDIATYPE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ipNetToMediaType(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in ipNetToMediaTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the tcpConnTable table, if anything else needs to be done */
int
tcpConnTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_TCPCONNSTATE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_tcpConnState(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_TCPCONNLOCALADDRESS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_tcpConnLocalAddress(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_IPADDRESS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_TCPCONNLOCALPORT:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_tcpConnLocalPort(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_TCPCONNREMADDRESS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_tcpConnRemAddress(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_IPADDRESS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_TCPCONNREMPORT:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_tcpConnRemPort(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in tcpConnTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = tcpConnTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_TCPCONNSTATE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_tcpConnState(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_tcpConnState(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_TCPCONNSTATE:
                            {
                                int ret;
                                ret = set_tcpConnState(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    tcpConnTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_TCPCONNSTATE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_tcpConnState(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in tcpConnTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the udpTable table, if anything else needs to be done */
int
udpTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_UDPLOCALADDRESS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_udpLocalAddress(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_IPADDRESS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_UDPLOCALPORT:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_udpLocalPort(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in udpTable_handler: unknown column\n");
                }
                break;


            default:
                snmp_log(LOG_ERR, "problem encountered in udpTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the egpNeighTable table, if anything else needs to be done */
int
egpNeighTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_EGPNEIGHSTATE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighState(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHADDR:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighAddr(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_IPADDRESS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHAS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighAs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHINMSGS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighInMsgs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHINERRS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighInErrs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHOUTMSGS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighOutMsgs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHOUTERRS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighOutErrs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHINERRMSGS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighInErrMsgs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHOUTERRMSGS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighOutErrMsgs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHSTATEUPS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighStateUps(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHSTATEDOWNS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighStateDowns(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHINTERVALHELLO:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighIntervalHello(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHINTERVALPOLL:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighIntervalPoll(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHMODE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighMode(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_EGPNEIGHEVENTTRIGGER:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_egpNeighEventTrigger(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in egpNeighTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = egpNeighTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_EGPNEIGHEVENTTRIGGER:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_egpNeighEventTrigger(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_egpNeighEventTrigger(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_EGPNEIGHEVENTTRIGGER:
                            {
                                int ret;
                                ret = set_egpNeighEventTrigger(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    egpNeighTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_EGPNEIGHEVENTTRIGGER:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_egpNeighEventTrigger(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in egpNeighTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the rs232PortTable table, if anything else needs to be done */
int
rs232PortTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_RS232PORTINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232PortIndex(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232PORTTYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232PortType(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232PORTINSIGNUMBER:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232PortInSigNumber(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232PORTOUTSIGNUMBER:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232PortOutSigNumber(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232PORTINSPEED:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232PortInSpeed(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232PORTOUTSPEED:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232PortOutSpeed(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232PORTINFLOWTYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232PortInFlowType(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232PORTOUTFLOWTYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232PortOutFlowType(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in rs232PortTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = rs232PortTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_RS232PORTINSPEED:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232PortInSpeed(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232PortInSpeed(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232PORTOUTSPEED:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232PortOutSpeed(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232PortOutSpeed(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232PORTINFLOWTYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232PortInFlowType(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232PortInFlowType(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232PORTOUTFLOWTYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232PortOutFlowType(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232PortOutFlowType(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_RS232PORTINSPEED:
                            {
                                int ret;
                                ret = set_rs232PortInSpeed(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232PORTOUTSPEED:
                            {
                                int ret;
                                ret = set_rs232PortOutSpeed(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232PORTINFLOWTYPE:
                            {
                                int ret;
                                ret = set_rs232PortInFlowType(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232PORTOUTFLOWTYPE:
                            {
                                int ret;
                                ret = set_rs232PortOutFlowType(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    rs232PortTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_RS232PORTINSPEED:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232PortInSpeed(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232PORTOUTSPEED:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232PortOutSpeed(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232PORTINFLOWTYPE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232PortInFlowType(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232PORTOUTFLOWTYPE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232PortOutFlowType(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in rs232PortTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the rs232AsyncPortTable table, if anything else needs to be done */
int
rs232AsyncPortTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_RS232ASYNCPORTINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232AsyncPortIndex(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232ASYNCPORTBITS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232AsyncPortBits(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232ASYNCPORTSTOPBITS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232AsyncPortStopBits(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232ASYNCPORTPARITY:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232AsyncPortParity(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232ASYNCPORTAUTOBAUD:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232AsyncPortAutobaud(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232ASYNCPORTPARITYERRS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232AsyncPortParityErrs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232ASYNCPORTFRAMINGERRS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232AsyncPortFramingErrs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232ASYNCPORTOVERRUNERRS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232AsyncPortOverrunErrs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in rs232AsyncPortTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = rs232AsyncPortTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_RS232ASYNCPORTBITS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232AsyncPortBits(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232AsyncPortBits(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232ASYNCPORTSTOPBITS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232AsyncPortStopBits(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232AsyncPortStopBits(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232ASYNCPORTPARITY:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232AsyncPortParity(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232AsyncPortParity(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232ASYNCPORTAUTOBAUD:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232AsyncPortAutobaud(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232AsyncPortAutobaud(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_RS232ASYNCPORTBITS:
                            {
                                int ret;
                                ret = set_rs232AsyncPortBits(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232ASYNCPORTSTOPBITS:
                            {
                                int ret;
                                ret = set_rs232AsyncPortStopBits(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232ASYNCPORTPARITY:
                            {
                                int ret;
                                ret = set_rs232AsyncPortParity(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232ASYNCPORTAUTOBAUD:
                            {
                                int ret;
                                ret = set_rs232AsyncPortAutobaud(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    rs232AsyncPortTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_RS232ASYNCPORTBITS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232AsyncPortBits(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232ASYNCPORTSTOPBITS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232AsyncPortStopBits(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232ASYNCPORTPARITY:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232AsyncPortParity(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232ASYNCPORTAUTOBAUD:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232AsyncPortAutobaud(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in rs232AsyncPortTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the rs232SyncPortTable table, if anything else needs to be done */
int
rs232SyncPortTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_RS232SYNCPORTINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortIndex(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTCLOCKSOURCE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortClockSource(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTFRAMECHECKERRS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortFrameCheckErrs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTTRANSMITUNDERRUNERRS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortTransmitUnderrunErrs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTRECEIVEOVERRUNERRS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortReceiveOverrunErrs(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTINTERRUPTEDFRAMES:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortInterruptedFrames(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTABORTEDFRAMES:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortAbortedFrames(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTROLE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortRole(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTENCODING:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortEncoding(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTRTSCONTROL:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortRTSControl(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTRTSCTSDELAY:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortRTSCTSDelay(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTMODE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortMode(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTIDLEPATTERN:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortIdlePattern(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232SYNCPORTMINFLAGS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232SyncPortMinFlags(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in rs232SyncPortTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = rs232SyncPortTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_RS232SYNCPORTCLOCKSOURCE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232SyncPortClockSource(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232SyncPortClockSource(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232SYNCPORTROLE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232SyncPortRole(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232SyncPortRole(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232SYNCPORTENCODING:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232SyncPortEncoding(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232SyncPortEncoding(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232SYNCPORTRTSCONTROL:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232SyncPortRTSControl(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232SyncPortRTSControl(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232SYNCPORTRTSCTSDELAY:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232SyncPortRTSCTSDelay(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232SyncPortRTSCTSDelay(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232SYNCPORTMODE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232SyncPortMode(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232SyncPortMode(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232SYNCPORTIDLEPATTERN:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232SyncPortIdlePattern(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232SyncPortIdlePattern(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_RS232SYNCPORTMINFLAGS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_rs232SyncPortMinFlags(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_rs232SyncPortMinFlags(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_RS232SYNCPORTCLOCKSOURCE:
                            {
                                int ret;
                                ret = set_rs232SyncPortClockSource(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTROLE:
                            {
                                int ret;
                                ret = set_rs232SyncPortRole(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTENCODING:
                            {
                                int ret;
                                ret = set_rs232SyncPortEncoding(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTRTSCONTROL:
                            {
                                int ret;
                                ret = set_rs232SyncPortRTSControl(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTRTSCTSDELAY:
                            {
                                int ret;
                                ret = set_rs232SyncPortRTSCTSDelay(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTMODE:
                            {
                                int ret;
                                ret = set_rs232SyncPortMode(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTIDLEPATTERN:
                            {
                                int ret;
                                ret = set_rs232SyncPortIdlePattern(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTMINFLAGS:
                            {
                                int ret;
                                ret = set_rs232SyncPortMinFlags(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    rs232SyncPortTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_RS232SYNCPORTCLOCKSOURCE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232SyncPortClockSource(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTROLE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232SyncPortRole(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTENCODING:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232SyncPortEncoding(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTRTSCONTROL:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232SyncPortRTSControl(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTRTSCTSDELAY:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232SyncPortRTSCTSDelay(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTMODE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232SyncPortMode(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTIDLEPATTERN:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232SyncPortIdlePattern(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_RS232SYNCPORTMINFLAGS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_rs232SyncPortMinFlags(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in rs232SyncPortTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the rs232InSigTable table, if anything else needs to be done */
int
rs232InSigTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_RS232INSIGPORTINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232InSigPortIndex(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232INSIGNAME:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232InSigName(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232INSIGSTATE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232InSigState(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232INSIGCHANGES:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232InSigChanges(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in rs232InSigTable_handler: unknown column\n");
                }
                break;


            default:
                snmp_log(LOG_ERR, "problem encountered in rs232InSigTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the rs232OutSigTable table, if anything else needs to be done */
int
rs232OutSigTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_RS232OUTSIGPORTINDEX:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232OutSigPortIndex(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232OUTSIGNAME:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232OutSigName(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232OUTSIGSTATE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232OutSigState(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_RS232OUTSIGCHANGES:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_rs232OutSigChanges(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in rs232OutSigTable_handler: unknown column\n");
                }
                break;


            default:
                snmp_log(LOG_ERR, "problem encountered in rs232OutSigTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the ifXTable table, if anything else needs to be done */
int
ifXTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_IFNAME:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                retval = get_ifName(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFINMULTICASTPKTS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifInMulticastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFINBROADCASTPKTS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifInBroadcastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFOUTMULTICASTPKTS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifOutMulticastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFOUTBROADCASTPKTS:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifOutBroadcastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFHCINOCTETS:
                            {
                                U64 *retval;
                                size_t retval_len = 0;
                                retval = get_ifHCInOctets(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER64,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFHCINUCASTPKTS:
                            {
                                U64 *retval;
                                size_t retval_len = 0;
                                retval = get_ifHCInUcastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER64,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFHCINMULTICASTPKTS:
                            {
                                U64 *retval;
                                size_t retval_len = 0;
                                retval = get_ifHCInMulticastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER64,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFHCINBROADCASTPKTS:
                            {
                                U64 *retval;
                                size_t retval_len = 0;
                                retval = get_ifHCInBroadcastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER64,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFHCOUTOCTETS:
                            {
                                U64 *retval;
                                size_t retval_len = 0;
                                retval = get_ifHCOutOctets(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER64,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFHCOUTUCASTPKTS:
                            {
                                U64 *retval;
                                size_t retval_len = 0;
                                retval = get_ifHCOutUcastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER64,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFHCOUTMULTICASTPKTS:
                            {
                                U64 *retval;
                                size_t retval_len = 0;
                                retval = get_ifHCOutMulticastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER64,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFHCOUTBROADCASTPKTS:
                            {
                                U64 *retval;
                                size_t retval_len = 0;
                                retval = get_ifHCOutBroadcastPkts(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_COUNTER64,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFLINKUPDOWNTRAPENABLE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifLinkUpDownTrapEnable(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFHIGHSPEED:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifHighSpeed(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_GAUGE,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFPROMISCUOUSMODE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifPromiscuousMode(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFCONNECTORPRESENT:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifConnectorPresent(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFALIAS:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                retval = get_ifAlias(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFCOUNTERDISCONTINUITYTIME:
                            {
                                u_long *retval;
                                size_t retval_len = 0;
                                retval = get_ifCounterDiscontinuityTime(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_TIMETICKS,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in ifXTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = ifXTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_IFLINKUPDOWNTRAPENABLE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ifLinkUpDownTrapEnable(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ifLinkUpDownTrapEnable(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IFPROMISCUOUSMODE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ifPromiscuousMode(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ifPromiscuousMode(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IFALIAS:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ifAlias(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ifAlias(request->requestvb->type,
                                                   (char *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IFLINKUPDOWNTRAPENABLE:
                            {
                                int ret;
                                ret = set_ifLinkUpDownTrapEnable(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IFPROMISCUOUSMODE:
                            {
                                int ret;
                                ret = set_ifPromiscuousMode(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IFALIAS:
                            {
                                int ret;
                                ret = set_ifAlias(ci->data_context,
                                             (char *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    ifXTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IFLINKUPDOWNTRAPENABLE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ifLinkUpDownTrapEnable(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IFPROMISCUOUSMODE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ifPromiscuousMode(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IFALIAS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ifAlias(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in ifXTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the ifStackTable table, if anything else needs to be done */
int
ifStackTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_IFSTACKSTATUS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifStackStatus(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in ifStackTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = ifStackTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_IFSTACKSTATUS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ifStackStatus(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ifStackStatus(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IFSTACKSTATUS:
                            {
                                int ret;
                                ret = set_ifStackStatus(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                                  if (*request->requestvb->val.integer ==
                                      RS_DESTROY) {
                                          ci->new_row = -1;
                                  }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    ifStackTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IFSTACKSTATUS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ifStackStatus(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in ifStackTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the ifTestTable table, if anything else needs to be done */
int
ifTestTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_IFTESTID:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifTestId(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFTESTSTATUS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifTestStatus(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFTESTTYPE:
                            {
                                oid *retval;
                                size_t retval_len = 0;
                                retval = get_ifTestType(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFTESTRESULT:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifTestResult(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFTESTCODE:
                            {
                                oid *retval;
                                size_t retval_len = 0;
                                retval = get_ifTestCode(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFTESTOWNER:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                retval = get_ifTestOwner(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in ifTestTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = ifTestTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_IFTESTID:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ifTestId(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ifTestId(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IFTESTSTATUS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ifTestStatus(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ifTestStatus(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IFTESTTYPE:
                            {
                                oid *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ifTestType(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ifTestType(request->requestvb->type,
                                                   (oid *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IFTESTOWNER:
                            {
                                char *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ifTestOwner(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ifTestOwner(request->requestvb->type,
                                                   (char *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IFTESTID:
                            {
                                int ret;
                                ret = set_ifTestId(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IFTESTSTATUS:
                            {
                                int ret;
                                ret = set_ifTestStatus(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IFTESTTYPE:
                            {
                                int ret;
                                ret = set_ifTestType(ci->data_context,
                                             (oid *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                          case COLUMN_IFTESTOWNER:
                            {
                                int ret;
                                ret = set_ifTestOwner(ci->data_context,
                                             (char *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    ifTestTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IFTESTID:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ifTestId(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IFTESTSTATUS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ifTestStatus(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IFTESTTYPE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ifTestType(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IFTESTOWNER:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ifTestOwner(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in ifTestTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the ifRcvAddressTable table, if anything else needs to be done */
int
ifRcvAddressTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void *data_context = NULL;

    oid *suffix;
    size_t suffix_len;

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);
    
    for(request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context =  netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context =  netsnmp_extract_iterator_context(request);
            break;

        default: /* == the other SET modes */
            ci = netsnmp_oid_stash_get_data(commitStorage,
                                            suffix+1, suffix_len-1);
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch(reqinfo->mode) {
            case MODE_GET:
                switch(table_info->colnum) {
                    case COLUMN_IFRCVADDRESSSTATUS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifRcvAddressStatus(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    case COLUMN_IFRCVADDRESSTYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                retval = get_ifRcvAddressType(data_context, &retval_len);
                                if (retval)
                                    snmp_set_var_typed_value(var, ASN_INTEGER,
                                                         (const u_char *) retval,
                                                         retval_len);
                            }
                        break;

                    default:
                /** We shouldn't get here */
                        snmp_log(LOG_ERR, "problem encountered in ifRcvAddressTable_handler: unknown column\n");
                }
                break;

            case MODE_SET_RESERVE1:
                ci = netsnmp_oid_stash_get_data(commitStorage,
                                                suffix+1, suffix_len-1);
                
                if (!ci) {
                    /** create the commit storage info */
                    ci = SNMP_MALLOC_STRUCT(commitInfo);
                    if (!data_context) {
                        ci->data_context = ifRcvAddressTable_create_data_context(table_info->indexes, COLUMN_):
                        ci->new_row = 1;
                    } else {
                        ci->data_context = data_context;
                    }
                    netsnmp_oid_stash_add_data(&commitStorage,
                                               suffix+1, suffix_len-1, ci);
                }
            break;
                
            case MODE_SET_RESERVE2:
                switch(table_info->colnum) {
                          case COLUMN_IFRCVADDRESSSTATUS:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ifRcvAddressStatus(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ifRcvAddressStatus(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                          case COLUMN_IFRCVADDRESSTYPE:
                            {
                                long *retval;
                                size_t retval_len = 0;
                                struct undoInfo *ui = NULL;
                                int ret;
                                
                    /** first, get the old value */
                                retval = get_ifRcvAddressType(ci->data_context, &retval_len);
                                if (retval) {
                                    ui = SNMP_MALLOC_STRUCT(undoInfo);
                                    ui->len = retval_len;
                                    memdup((u_char **) &ui->ptr,
                                           (u_char *) retval,
                                           ui->len);
                                }

                    /** check the new value, possibly against the
                        older value for a valid state transition */
                                ret = check_ifRcvAddressType(request->requestvb->type,
                                                   (long *) request->requestvb->val.string,
                                                   request->requestvb->val_len,
                                                   retval, retval_len);
                                if (ret != 0) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                    mib-2_free_undoInfo(ui);
                                } else if (ui) {
                        /** remember information for undo purposes later */
                                    netsnmp_oid_stash_add_data(&undoStorage,
                                                               suffix,
                                                               suffix_len,
                                                               ui);
                                }
                                
                            }
                            break;
                    default:
                       netsnmp_set_request_error(reqinfo, request,
                                                 SNMP_ERR_NOTWRITABLE);
                       break;
                 }
                break;

            case MODE_SET_ACTION:
            /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IFRCVADDRESSSTATUS:
                            {
                                int ret;
                                ret = set_ifRcvAddressStatus(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                                  if (*request->requestvb->val.integer ==
                                      RS_DESTROY) {
                                          ci->new_row = -1;
                                  }
                            }
                            break;
                          case COLUMN_IFRCVADDRESSTYPE:
                            {
                                int ret;
                                ret = set_ifRcvAddressType(ci->data_context,
                                             (long *) request->requestvb->val.string,
                                             request->requestvb->val_len);
                                if (ret) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              ret);
                                }
                            }
                            break;
                 }
                break;

            case MODE_SET_COMMIT:
                if (!ci->have_committed) {
                    /** do this once per row only */
                    ifRcvAddressTable_commit_row(&ci->data_context, ci->new_row);
                    ci->have_committed = 1;
                }
                break;

            case MODE_SET_UNDO:
             /** save a variable copy */
                switch(table_info->colnum) {
                          case COLUMN_IFRCVADDRESSSTATUS:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ifRcvAddressStatus(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                          case COLUMN_IFRCVADDRESSTYPE:
                            {
                                int retval;
                                struct undoInfo *ui;
                                ui = netsnmp_oid_stash_get_data(undoStorage,
                                                                suffix,
                                                                suffix_len);
                                retval = set_ifRcvAddressType(ci->data_context, ui->ptr,
                                                ui->len);
                                if (retval) {
                                    netsnmp_set_request_error(reqinfo, request,
                                                              SNMP_ERR_UNDOFAILED);
                                }
                            }
                            break;
                }
                break;
                
            case MODE_SET_FREE:
                break;

            default:
                snmp_log(LOG_ERR, "problem encountered in ifRcvAddressTable_handler: unsupported mode\n");
        }
    }

    /** clean up after all requset processing has ended */
    switch(reqinfo->mode) {
    case MODE_SET_UNDO:
    case MODE_SET_FREE:
    case MODE_SET_COMMIT:
        /** clear out the undo cache */
        netsnmp_oid_stash_free(&undoStorage, mib-2_free_undoInfo);
        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
    }

    return SNMP_ERR_NOERROR;
}
